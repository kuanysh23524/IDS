package com.example.diplom_Kuks_team.kuksteam.services;

import com.example.diplom_Kuks_team.kuksteam.models.TrafficRecord;
import com.example.diplom_Kuks_team.kuksteam.repositories.TrafficRecordRepository;
import org.pcap4j.core.*;
import org.pcap4j.packet.IpV4Packet;
import org.pcap4j.packet.Packet;
import org.pcap4j.packet.TcpPacket;
import org.pcap4j.packet.UdpPacket;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;

@Service
public class NetworkCaptureService {

    private static final int CAPTURE_DURATION = 900; // –í—Ä–µ–º—è –∑–∞—Ö–≤–∞—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    private static final Map<String, Integer> requestCounter = new HashMap<>();
    private static final Map<String, Long> lastRequestTime = new HashMap<>();
    @Autowired
    TrafficRecordRepository trafficRecordRepository;


//    @PostConstruct
//    public void startCapture() {
//        CompletableFuture.runAsync(this::capturePackets);
//    }


    private volatile boolean capturing = false;

    public void startCapture() {
        if (capturing) {
            return;  // –ï—Å–ª–∏ –∑–∞—Ö–≤–∞—Ç —É–∂–µ –∏–¥–µ—Ç, –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        }

        capturing = true;  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –∑–∞—Ö–≤–∞—Ç–∞ –≤ true

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —Ñ–ª–∞–≥ –∑–∞—Ö–≤–∞—Ç–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ true
        if (capturing == true) {
            CompletableFuture.runAsync(this::capturePackets);  // –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞—Ö–≤–∞—Ç –ø–∞–∫–µ—Ç–æ–≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        } else {
            // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–æ–∫ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –∑–¥–µ—Å—å, –Ω–æ –ª—É—á—à–µ –≤ —Ç–∞–∫–∏—Ö —Å–ª—É—á–∞—è—Ö —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å
            // –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –º–µ—Ç–æ–¥ –Ω–µ –¥–æ–ª–∂–µ–Ω –Ω–∏—á–µ–≥–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å (void).
        }
    }

    public void stopCapture() {
        capturing = false;

    }

    public void capturePackets() {
        try {
            List<PcapNetworkInterface> devices = Pcaps.findAllDevs();

            if (devices.isEmpty()) {
                System.out.println("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ç–µ–≤—ã—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤.");
                return;
            }

            System.out.println("üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã:");
            for (int i = 0; i < devices.size(); i++) {
                System.out.println(i + ": " + devices.get(i).getName() + " - " + devices.get(i).getDescription());
            }
//            Optional<NetworkDevices> networkDevices = networkDevicesRepository.findByName(name);
//            System.out.println(networkDevices.isPresent());

            FileWriter writer = new FileWriter("src/main/resources/data/live_traffic.csv", true);
//            writer.append("src_ip,dst_ip,src_port,dst_port,protocol,bytes,attack_type\n");

            for (PcapNetworkInterface device : devices) {
                if (device.getName().contains("Loopback")) {
                    continue;
                }

//                Optional<NetworkDevices> networkDevices = networkDevicesRepository.findByName(name);
//
                if (device.getDescription().contains("MediaTek Wi-Fi 6 MT7921 Wireless LAN Card"))
//                if (device.getDescription().equals(networkDevices.get().getDescription()))
                {


                    System.out.println("üîç –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: " + device.getName());

                    try (PcapHandle handle = device.openLive(65536, PcapNetworkInterface.PromiscuousMode.PROMISCUOUS, 10)) {
                        System.out.println("‚úÖ –ó–∞—Ö–≤–∞—Ç –Ω–∞—á–∞—Ç –Ω–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ: " + device.getName());

                        long startTime = System.currentTimeMillis();

                        while (capturing && System.currentTimeMillis() - startTime < CAPTURE_DURATION * 1000) {
                            try {
                                Packet packet = handle.getNextPacketEx();
                                processPacket(packet, writer);
                            } catch (TimeoutException e) {
                                System.out.println("‚è≥ –¢–∞–π–º-–∞—É—Ç –ø—Ä–∏ –æ–∂–∏–¥–∞–Ω–∏–∏ –ø–∞–∫–µ—Ç–∞...");
                            }
                        }

                    } catch (PcapNativeException | NotOpenException e) {
                        System.out.println("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å " + device.getName() + ": " + e.getMessage());
                    }
                }

            }


            writer.close();
            System.out.println("‚úÖ –î–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∞–Ω—ã –≤ live_traffic.csv");

        } catch (IOException | PcapNativeException e) {
            System.out.println("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤ —Ñ–∞–π–ª: " + e.getMessage());
        }
    }



   // Method scanning attacks--------------------------------------------------------------------------

    private static final int PORT_SCAN_THRESHOLD = 7;
    private static final int PACKET_SIZE_THRESHOLD = 1400;

    private static final int DDOS_REQUEST_COUNT = 5;        // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—ã—Å—Ç—Ä—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    private static final int DDOS_INTERVAL_MS = 1000;       // –≤ —Ç–µ—á–µ–Ω–∏–µ 1 —Å–µ–∫—É–Ω–¥—ã

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—á—ë—Ç—á–∏–∫–∏
//    private final Map<String, Integer> requestCounter = new HashMap<>();
    private final Map<String, List<Long>> recentRequests = new HashMap<>();

    private void processPacket(Packet packet, FileWriter writer) throws IOException {
        if (!packet.contains(IpV4Packet.class)) return;

        IpV4Packet ipPacket = packet.get(IpV4Packet.class);
        String srcIp = ipPacket.getHeader().getSrcAddr().getHostAddress();
        String dstIp = ipPacket.getHeader().getDstAddr().getHostAddress();
        int length = packet.length();
        String protocol = "OTHER";
        int srcPort = 0, dstPort = 0;
        String attackType = "NORMAL";

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –∏ –ø–æ—Ä—Ç–æ–≤
        if (packet.contains(TcpPacket.class)) {
            TcpPacket tcpPacket = packet.get(TcpPacket.class);
            srcPort = tcpPacket.getHeader().getSrcPort().valueAsInt();
            dstPort = tcpPacket.getHeader().getDstPort().valueAsInt();
            protocol = "TCP";

            // SYN Flood Detection
            if (tcpPacket.getHeader().getSyn() && !tcpPacket.getHeader().getAck()) {
                attackType = "SYN_FLOOD";
            }

            // NULL Packet Detection
            if (!tcpPacket.getHeader().getSyn() &&
                    !tcpPacket.getHeader().getAck() &&
                    !tcpPacket.getHeader().getFin() &&
                    !tcpPacket.getHeader().getRst() &&
                    !tcpPacket.getHeader().getPsh() &&
                    !tcpPacket.getHeader().getUrg()) {
                attackType = "NULL_PACKET";
            }

        } else if (packet.contains(UdpPacket.class)) {
            UdpPacket udpPacket = packet.get(UdpPacket.class);
            srcPort = udpPacket.getHeader().getSrcPort().valueAsInt();
            dstPort = udpPacket.getHeader().getDstPort().valueAsInt();
            protocol = "UDP";
        }

        // Port Scan Detection
        String ipPortKey = srcIp + ":" + dstPort;
        requestCounter.put(ipPortKey, requestCounter.getOrDefault(ipPortKey, 0) + 1);
        if (requestCounter.get(ipPortKey) > PORT_SCAN_THRESHOLD) {
            attackType = "PORT_SCAN";
        }

        // DDoS / Brute-force Detection (–º—è–≥—á–µ)
        // –¢–æ–ª—å–∫–æ –¥–ª—è –∏—Å—Ö–æ–¥—è—â–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞ (–Ω–∞—à–∞ —Å–µ—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä 10.x.x.x)
        if (srcIp.startsWith("10.")) {
            long currentTime = System.currentTimeMillis();
            List<Long> times = recentRequests.getOrDefault(srcIp, new ArrayList<>());
            times.add(currentTime);
            times.removeIf(t -> currentTime - t > DDOS_INTERVAL_MS);
            recentRequests.put(srcIp, times);

            if (times.size() >= DDOS_REQUEST_COUNT) {
                attackType = "DDOS_OR_BRUTE_FORCE";
            }
        }

        // Malformed Packet Detection (–æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π –ø–∞–∫–µ—Ç, –Ω–µ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
        if (length > PACKET_SIZE_THRESHOLD && !ipPacket.getHeader().getMoreFragmentFlag()) {
            attackType = "MALFORMED_PACKET";
        }

        // –ó–∞–ø–∏—Å—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        TrafficRecord record = new TrafficRecord(
                null, srcIp, dstIp, srcPort, dstPort, protocol, length, attackType, LocalDateTime.now()
        );
        trafficRecordRepository.save(record);

        // –ó–∞–ø–∏—Å—å –≤ CSV
        writer.append(String.join(",", srcIp, dstIp,
                        String.valueOf(srcPort), String.valueOf(dstPort),
                        protocol, String.valueOf(length), attackType))
                .append("\n");
        writer.flush();
    }


}